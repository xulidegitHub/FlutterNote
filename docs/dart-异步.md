# Dart是单线程的
## 程序中的耗时操作
### 开发中的耗时操作
* 在开发中，我们经常会遇到一些耗时的操作需要完成，比如网络请求，文件读取等等。
* 如果我们在主线程一直在等待这些耗时的操作完成，那么就会经行阻塞，无法响应其他事件，比如用户的点击。
* 显然，我们不能这么干！！

### 如何处理耗时操作？
针对如何处理耗时的操作，不同的语言有不同的处理方式。
* 处理方式一：多线程，比如java，C++，我们普遍的做法是开启一个新的线程（Thread）,在新的线程中完成这些异步的操作，再通过线程间的通信的方式，将拿到的数据传递给主线程。
* 处理方式二：单线程+事件循环，比如javaScript,Dart都是基于单线程加事件循环来完成耗时操作的处理的。不过，单线程如何能进行耗时的操作呢？

## 单线程的异步操作
有很多人会有疑问，单线程还怎么做异步操作呢？其实，他们并不冲突
* 因为我们的一个应用程序大部分时间都是出于空闲的状态的，并不是无限制的在和用户经行交互。
* 比如等待用户点击，网络请求数据的返回，文件读写和IO操作，这些等待的行为并不会阻塞我们的线程。
* 这是因为类似于网络请求，文件读写IO，我们都可以基于非阻塞调用。

## 阻塞式调用和非阻塞式调用
阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态。
* 阻塞式调用：调用结果返回之前，当前线程会被挂起，调用线程只有在得到调用结果之后才会继续执行。
* 非组塞式调用：调用执行之后，当前线程不会停止执行，只需要过一段来检查一下有没有结果返回即可。
我们用一个生活中的例子来模拟：
* 你中午饿了，需要点一份外卖，点外卖的动作就是我们的调用，拿到最后点的外卖就是我们要等待的结果。
* 组塞式调用：点了外卖，不再做任何事情，就是在傻傻的等待，你的线程停止了任何其他的工作。
* 非阻塞式调用：点了外卖，继续做其他事情：继续工作、打把游戏，你的线程没有继续执行其他事情，只需要偶尔去看一下有没有人敲门，外卖有没有送到即可。
而我们开发中的很多耗时操作，都可以基于这样的非阻塞式调用
* 比如网络请求本身使用了Socket通信，而Socket本身提供了select模型，可以进行非阻塞方式的工作；
* 比如文件读写的IO操作，我们可以使用操作系统提供的基于事件的回调机制；
这些操作都不会阻塞我们单线程的继续执行，我们的线程在等待的过程中可以继续去做别的事情：喝杯咖啡、打把游戏，等真正有了响应，再去进行对应的处理即可。
这时，我们可能有两个问题：
问题一：如果在多核CPU中，单线程是不是没有充分利用CPU呢？
问题二：单线程是如何来处理网络通信，IO操作它们返回的结果呢？答案就是事件循环。

# Dart事件循环
## 什么是事件循环?
单线程模型中主要就是在维护着一个事件循环。
事件循环是什么呢？
* 事实上事件循环并不复杂，他就是将需要处理的一系列事件（包括点击事件，IO事件，网络事件）放在一个事件队列中。
* 不断的从事件队列中取出事件，并执行其对应需要执行的代码块，直到事件队列清空位置。
我们来写一个事件循环的伪代码：
```dart
// 这里我使用数组模拟队列, 先进先出的原则
List eventQueue = []; 
var event;
// 事件循环从启动的一刻，永远在执行
while (true) {
  if (eventQueue.length > 0) {
    // 取出一个事件
    event = eventQueue.removeAt(0);
    // 执行该事件
    event();
  }
}
```
当我们有一些事件时，比如点击事件，IO事件，网络事件时，他们就会被加入到eventloop中，当发现事件队列不为空时发现，就会取出事件，并且执行。

## 事件循环代码模拟
这里我们来看一段伪代码，理解点击事件和网络请求的事件是如何被执行的：
* 一个RaisedButton,当发生点击执行onPressed函数。
* onPressed函数中，我们发送了一个网络请求，请求成功后会执行then中的回调函数。
```dart
RaisedButton(
  child: Text('Click me'),
  onPressed: () {
    final myFuture = http.get('https://example.com');
    myFuture.then((response) {
      if (response.statusCode == 200) {
        print('Success!');
      }
    });
  },
)
```
这些代码是如何放在事件循环中执行的呢？
* 当用户发生点击的时候，onPressed回调函数被放入事件循环中执行，执行的过程中发送了一个网络请求。
* 网络请求发出去之后，该事件循环不会被阻塞，而是发现要执行的onPressed函数已经结束，会将它丢掉。
* 网络请求成功后，会执行then中传入的回调函数，这也是一个事件，该事件被放入到事件循环中执行，执行完毕后，事件循环将其丢弃。
尽管onPressed和then中的回到有一些差异，但是它们对于事件循环来说，都是告诉它：我有一段代码需要执行，快点帮我完成。

# Dart的异步操作
Dart中的异步操作主要使用Future以及async,awiat。
## 认识Future
### 同步的网络请求
```dart
import "dart:io";
main(List<String> args) {
  print("main function start");
  print(getNetworkData());
  print("main function end");
}
String getNetworkData() {
  sleep(Duration(seconds: 3));
  return "network data";
}
```
上面getNetworkData会阻塞main函数的执行。显然，上面的代码不是我们想要的执行效果，因为网络请求阻塞了main函数，那么意味着其后所有的代码都无法正常的继续执行。
### 异步的网络请求
我们来对我们上面的代码进行改进,代码如下:
* 和刚才的代码唯一的区别在于我使用了Future对象来将耗时的操作放在了其中传入的函数中;
* 稍后,我们会讲解他具体的一些API,我们就暂时知道我创建了一个Future实例即可;
```dart
import "dart:io";

main(List<String> args) {
  print("main function start");
  print(getNetworkData());
  print("main function end");
}
Future<String> getNetworkData() {
  return Future<String>(() {
    sleep(Duration(seconds: 3));
    return "network data";
  });
}
```
我们来看一下代码的运行结果:
* 这一次的代码顺序执行,没有出现任何的阻塞现象.
* 和之前直接打印结果不同,这次我们打印了一个Future实例;
* 我们将一个耗时操作隔离起来



